#ifndef __REGRESSION
#define __REGRESSION

#include "Regression.h"

CRegression::CRegression(CCalculation &CCal)
{
    int M = CCal.common.Ncoeff;
    int dim = CCal.common.dim;
    int backend = CCal.common.backend;    
    TemplateMalloc(&CCal.sys.A, M*M, backend);   
    TemplateMalloc(&CCal.sys.b, M, backend);  
    TemplateMalloc(&CCal.sys.c, M, backend);  
    TemplateMalloc(&CCal.sys.d, M, backend);   
    //if (CCal.common.dftdata > 1)
        TemplateMalloc(&CCal.sys.dd, dim*CCal.common.inummax*M, backend);                     
}

void CRegression::LinearRegression(CCalculation &CCal)
{
    int M = CCal.common.Ncoeff;
    int dim = CCal.common.dim;
    int nc = CCal.common.nconfigs;
    int backend = CCal.common.backend;
    int dftdata =  CCal.common.dftdata;
    int nparam = 0;    
    
    dstype *A, *b, *c, *x, *f, *d, *dd, *q, *param;
    param = &CCal.app.muml[0];    
    A = &CCal.sys.A[0];
    b = &CCal.sys.b[0];
    c = &CCal.sys.c[0];
    x = &CCal.sys.x[0];
    f = &CCal.sys.f[0];
    q = &CCal.sys.q[0];
    d = &CCal.sys.d[0];
    dd = &CCal.sys.dd[0];
    
    // intialize regression matrix and vector
    ArraySetValue(A, 0.0, M*M, backend);  
    ArraySetValue(b, 0.0, M, backend);  
        
    //nc = 21;
    if (dftdata == 1) { // energies only
        for (int ci=0; ci<nc; ci++) { // loop over each configuration     
            // get atom positions for configuration ci   
            CCal.GetPositions(x, ci);   

            // get atom types for configuration ci
            CCal.GetAtomtypes(CCal.nb.atomtype, ci);           

            // form neighbor list
            CCal.NeighborList(x);

            // spherical harmonic descriptors
            ArraySetValue(d, 0.0, M, backend);  

            // compute descriptors 
            CCal.RadialSphericalHarmonicDescriptors(d, x, q, param, 0);

            // apply a weight to the descriptor vector             
            cpuArrayMultiplyScalar(d, CCal.config.we[ci], M);                                
            
            // form the regression vector b = b + we[ci]*e[ci]*d           
            cpuArrayAXPBY(b, b, d, 1.0, CCal.config.we[ci]*CCal.config.e[ci], M);                                
            
            // form the regression matrix A = A + d * d^T
            cpuKron(A, d, d, M, M);       
            
            cout<<"Descriptors for configuration # "<<ci+1<<": "<<endl;
            printArray2D(d, 1, M, backend);    
            //printArray2D(b, 1, M, backend);    
            //printArray2D(A, M, M, backend);            
            //error("here");
        }        
    }
    else if (dftdata == 2) { // forces only
        for (int ci=0; ci<nc; ci++) { // loop over each configuration          
            Int N = dim*CCal.common.inum;
            
            // get atom positions for configuration ci   
            CCal.GetPositions(x, ci);   

            // get atom types for configuration ci
            CCal.GetAtomtypes(CCal.nb.atomtype, ci);           

            // form neighbor list
            CCal.NeighborList(x);

            // spherical harmonic descriptors
            ArraySetValue(d, 0.0, M, backend);  
            ArraySetValue(dd, 0.0, N*M, backend);  

            // compute descriptors and their derivatives
            CCal.RadialSphericalHarmonicDescriptors(d, dd, x, q, param, 0);

            // apply a weight to the descriptors' derivatives             
            cpuArrayMultiplyScalar(dd, CCal.config.wf[ci], N*M);
            
            // get DFT forces
            CCal.GetForces(f, ci);                       
            
            // form the regression vector b = b + wf[ci]*dd^T*f                                
            PGEMTV(CCal.common.cublasHandle, N, M, &CCal.config.wf[ci], dd, N, f, inc1, &one, b, inc1, backend);    
            
            // form the regression matrix A = A + dd^T * dd
            PGEMTM(CCal.common.cublasHandle, M, M, N, &one, dd, N, dd, N, &one, A, M, backend);     
                        
            cout<<"Descriptors for configuration # "<<ci+1<<": "<<endl;
            printArray2D(d, 1, M, backend);    
            //printArray2D(b, 1, M, backend);    
            //printArray2D(A, M, M, backend);            
            //error("here");
        }                
    }
    else if (dftdata == 3) { // enegies and forces
        for (int ci=0; ci<nc; ci++) { // loop over each configuration          
            Int N = dim*CCal.common.inum;
            
            // get atom positions for configuration ci   
            CCal.GetPositions(x, ci);   

            // get atom types for configuration ci
            CCal.GetAtomtypes(CCal.nb.atomtype, ci);           

            // form neighbor list
            CCal.NeighborList(x);

            // spherical harmonic descriptors
            ArraySetValue(d, 0.0, M, backend);  
            ArraySetValue(dd, 0.0, N*M, backend);  
            
            // compute descriptors 
            CCal.RadialSphericalHarmonicDescriptors(d, dd, x, q, param, 0);

            // apply a weight to the descriptor vectors      
            cpuArrayMultiplyScalar(d, CCal.config.we[ci], M);
            
            // form the regression vector b = b + we[ci]*e[ci]*d            
            cpuArrayAXPBY(b, b, d, 1.0, CCal.config.we[ci]*CCal.config.e[ci], M);
            
            // form the regression matrix A = A + d * d^T
            cpuKron(A, d, d, M, M);                        
            
            // apply a weight to the descriptors' derivatives       
            cpuArrayMultiplyScalar(dd, CCal.config.wf[ci], N*M);            
            
            // get DFT forces 
            CCal.GetForces(f, ci);
                                    
            // form the regression vector b = b + wf[ci]*dd^T*f                                    
            PGEMTV(CCal.common.cublasHandle, N, M, &CCal.config.wf[ci], dd, N, f, inc1, &one, b, inc1, backend);    
            
            // form the regression matrix A = A + dd^T * dd
            PGEMTM(CCal.common.cublasHandle, M, M, N, &one, dd, N, dd, N, &one, A, M, backend);             
        }                
    }
    
    printArray2D(b, 1, M, backend);    
    printArray2D(A, M, M, backend);            
    
    // solve the linear system A*c = b         
    dstype *work=NULL;  
    Int *ipiv=NULL;
    TemplateMalloc(&work, M*M, backend);        
    TemplateMalloc(&ipiv, M+1, backend);           
    Inverse(CCal.common.cublasHandle, A, work, ipiv, M, 1, backend);     
    PGEMNV(CCal.common.cublasHandle, M, M, &one, A, M, b, inc1, &zero, c, inc1, backend);    
 
    dstype *a1 = new dstype[M];
    dstype *b1 = new dstype[M];
    dstype *d1 = new dstype[M];
    dstype *et = new dstype[M];
    dstype *x1 = new dstype[dim*CCal.common.inummax];    
    for (int ci=0; ci<nc; ci++) { // loop over each configuration     
        Int N = dim*CCal.common.inum;
        
        // get atom positions for configuration ci   
        CCal.GetPositions(x, ci);   

        // get atom types for configuration ci
        CCal.GetAtomtypes(CCal.nb.atomtype, ci);           

        // form neighbor list
        CCal.NeighborList(x);

        // spherical harmonic descriptors
        ArraySetValue(d, 0.0, M, backend);  

        // compute descriptors 
        CCal.RadialSphericalHarmonicDescriptors(d, dd, x, q, param, 0);
        
        dstype epsil = 1e-8;
        for (int i = 0; i<N; i++) {
            cpuArrayCopy(x1, x, N);  
            x1[i] = x1[i] + epsil;
            
            // form neighbor list
            CCal.NeighborList(x1);

            // spherical harmonic descriptors
            ArraySetValue(d1, 0.0, M, backend);  
            
            CCal.RadialSphericalHarmonicDescriptors(d1, x1, q, param, 0);      
            for (int j=0; j<M; j++) {
                et[j] = fabs((d1[j]-d[j])/epsil - dd[i + N*j]);
                a1[j] = (d1[j]-d[j])/epsil;
                b1[
            }
            cout<<"Maximum absolute error: "<<cpuArrayMax(et, M)<<endl;                  
        }
        error("here");
        
        dstype en = 0.0;
        for (int j=0; j<M; j++)
            en += d[j]*c[j];
        
        // get DFT forces 
        CCal.GetForces(f, ci);
        PGEMNV(CCal.common.cublasHandle, N, M, &one, dd, N, c, inc1, &zero, x, inc1, backend);            
        
        cout<<"Configuration # "<<ci+1<<": "<<en<<"  "<<CCal.config.e[ci]<<endl;
        printArray2D(f, dim, 10, backend);
        printArray2D(x, dim, 10, backend);
        
//         for (int i=0; i<N; i++) {
//             x[i] = 0;
//             for (int j=0; j<M; j++)
//                 x[i] += dd[i + j*N]*c[j];
//         }
//         printArray2D(x, dim, 10, backend);
//         //error("here");
    }    
}

void CRegression::GaussianRegression(CCalculation &CCal)
{
}

void CRegression::NeuralNetRegression(CCalculation &CCal)
{
}
        
#endif        

